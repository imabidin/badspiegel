1. Problem: Statisches Parsen der options.php
Aktuelles Verhalten:
Die options.php wird bei jedem Aufruf von get_all_product_options() geparst (auch wenn der Cache greift, muss PHP die Datei zunÃ¤chst einlesen).
Bei 10.000 Zeilen entsteht Overhead durch:

Parsen des PHP-Arrays

Speicherverbrauch durch das $options_cache-Array

LÃ¶sung: JSON-basierte Optionen mit Lazy Loading

Konvertiere die options.php in eine JSON-Datei (z. B. product_options.json).

Lade die Daten nur bei Bedarf und cache sie persistent (z. B. via WordPress-Transients oder Object Cache):

php
Copy
function get_all_product_options() {
    $cache_key = 'product_options_json';
    $options = get_transient($cache_key);

    if (false === $options) {
        $json_file = trailingslashit(__DIR__) . 'product_options.json';
        $options = json_decode(file_get_contents($json_file), true);
        set_transient($cache_key, $options, WEEK_IN_SECONDS); // Cache fÃ¼r 1 Woche
    }

    return $options;
}
Vorteile:

JSON ist schneller zu parsen als PHP-Arrays.

Transients werden im Object Cache (Redis, Memcached) oder Datenbank gespeichert â†’ weniger Speicherdruck.

Bei Ã„nderungen: Cache einfach leeren.

2. Problem: Ineffiziente Filterlogik
Aktuelles Verhalten:
Die Funktion get_product_options() durchlÃ¤uft alle Optionen und prÃ¼ft jede Bedingung (applies_to, excluded_*) via array_intersect. Bei 100+ Optionen Ã— 100+ Produkten wird das langsam.

LÃ¶sung: Indexierung der Optionen
Baue ein Lookup-System, das Optionen direkt anhand von SKU, Kategorie oder Attributen findet:

php
Copy
// Beispiel: Indexierung im Cache
$indexed_options = [
    'by_sku' => [
        'PRODUCT-SKU-1' => ['option_key_1', 'option_key_2'],
    ],
    'by_category' => [
        'category-slug' => ['option_key_3'],
    ],
    'by_attribute' => [
        'beleuchtung_rundherum' => ['option_key_4'],
    ],
];
Vorteile:

Du sparst dir die Schleife durch alle Optionen.

Abfragen wie "Welche Optionen gelten fÃ¼r SKU X?" sind O(1).

Implementierungstipp:
Erzeuge den Index beim Laden der Optionen (z. B. in get_all_product_options()) und speichere ihn im Cache.

3. Problem: Redundante Kategorie-/Attribut-Abfragen
Aktuelles Verhalten:
wp_get_post_terms() wird mehrfach aufgerufen (z. B. fÃ¼r Kategorie-Slugs und -IDs). Das ist redundant.

LÃ¶sung: Kategorien/Attribute einmalig laden

Cache die Term-Abfragen im Produktobjekt:

php
Copy
$product_categories = $product->get_meta('_cached_category_slugs');
if (empty($product_categories)) {
    $product_categories = wp_get_post_terms($product_id, 'product_cat', ['fields' => 'slugs']);
    $product->update_meta_data('_cached_category_slugs', $product_categories);
}
Vorteile:

Vermeidet wiederholte Datenbankabfragen.

Besonders effektiv im Checkout/Warenkorb, wo dasselbe Produkt mehrfach verarbeitet wird.

4. Problem: GroÃŸe $product_attributes_combined-Arrays
Aktuelles Verhalten:
FÃ¼r jedes Produkt werden alle Attribute in kombinierte Slugs umgewandelt (z. B. pa_farbe:rot â†’ farbe_rot). Bei vielen Attributen entsteht Overhead.

LÃ¶sung: Attribut-Hashing

Generiere einen eindeutigen Hash der Attribute (z. B. md5(serialize($attributes))) und cache die gÃ¼ltigen Optionen pro Hash:

php
Copy
$attr_hash = $product->get_meta('_attribute_hash');
if (empty($attr_hash)) {
    $attr_hash = md5(serialize($product->get_attributes()));
    $product->update_meta_data('_attribute_hash', $attr_hash);
}

$cache_key = 'product_options_' . $product_id . '_' . $attr_hash;
$options = get_transient($cache_key);
Vorteile:

Wenn sich Attribute nicht Ã¤ndern, wird das Ergebnis direkt aus dem Cache gezogen.

5. Weitere Optimierungen
WP Object Cache nutzen:
Falls Redis/Memcached verfÃ¼gbar ist, ersetze get_transient() durch wp_cache_get() (noch schneller).

Frontend-Lazy Loading:
Lade Optionen per AJAX, sobald sie im Konfigurator gebraucht werden (nicht alle auf einmal).

Benchmarking:
Miss die Performance mit Tools wie Query Monitor (WordPress-Plugin) oder Blackfire.io, um EngpÃ¤sse zu identifizieren.

Zusammenfassung der MaÃŸnahmen
Datenformat wechseln:
options.php â†’ JSON + Transient-Caching.

Indexierung:
Lookup-Tabellen fÃ¼r SKUs, Kategorien und Attribute.

Term-Caching:
Kategorien/Attribute pro Produkt cachen.

Attribut-Hashing:
Optionen-Caching basierend auf Attribut-Ã„nderungen.

Mit diesen Ã„nderungen sollte die Performance selbst bei 10.000+ Zeilen stabil bleiben. ðŸš€